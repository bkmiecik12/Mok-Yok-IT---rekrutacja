Niestety nie mia³em nigdy do czynienia z frameworkiem Apache Spark, a ze jêzykiem Scala mia³em stycznoœæ jedynie podczas kilku æwiczeñ na studiach, wiêc do pierwszego zadania wybra³em dobrze mi znan¹ Javê.

Zadanie 1.

Status.java
Napisa³em klasê Status reprezentuj¹c¹ model danych z pliku statuses.json. Konstruktor przyjmuje z parametru JSONObject i rzutuje dane po etykietach do odpowiednich pól klasy.
Klasa implementuje interfejs Comparable w celu porównywania obiektów przy sortowaniu (nadpisana metoda compareTo).
Nazwy pól pozostawi³em takie jak w etykiety w pliku z danymi.

Converter.java
Ta klasa zawiera tylko metodê main, w której odbywa siê konwersja danych do pliku *.csv.
Zauwa¿y³em, ¿e plik statuses.json zawiera tablicê obiektów, wiêc zaimportowa³em j¹ do obiektu typu JSONArray.
Stamt¹d ka¿dy JSONObject rzutujê do Status i umieszczam na ArrayLiœcie, któr¹ sortujê za pomoc¹ metody compareTo.
Ka¿dy obiekt z ArrayListy konkatenujê do Stringa csv wed³ug schematu z treœci zadania. Stringa zapisujê do pliku statuses.csv.

Zadanie 2.

Zadanie2.sql

SELECT `kontakt_id`,`klient_id`,`pracownik_id`,`status`, max(`kontakt_ts`) FROM `statuses` GROUP BY klient_id

W tym zapytaniu potrzebujê wybraæ ostatni status klienta, wiêc u¿y³em funkcji max(), która zwraca najwiêksz¹ wartoœæ (w tym przypadku chodzi o atrybut `kontakt_ts`).
Dane pogrupowa³em po klient_id.

Zadanie 3.

Zadanie3.sql

ALTER TABLE statuses
ADD dzien date;

UPDATE statuses
SET dzien=kontakt_ts;

INSERT INTO `f_docieralnosc`(`data`, `sukcesy`, `utraty`, `do_ponowienia`)
SELECT dzien, 
COUNT(CASE status WHEN "zainteresowany" THEN 1 ELSE null END), 
COUNT(CASE status WHEN "niezainteresowany" THEN 1 ELSE null END), 
COUNT(CASE status WHEN "poczta_glosowa" THEN 1 WHEN "nie_ma_w_domu" THEN 1 ELSE null END) 
FROM statuses 
GROUP BY dzien;


To zadanie pozwoli³em sobie rozbiæ na 3 zapytania.
1) Doda³em kolumnê dzien typu date
2) Wype³ni³em j¹ danymi //zdajê sobie sprawê, ¿e przy wiêkszej iloœci danych takie rozwi¹zanie mo¿e nie byæ optymalne
3) W³aœciwe zapytanie - tabelê uzupe³niam unikatowym dniem (dziêki GROUP BY dzien), oraz liczbami okreœlaj¹cymi odpowiednie wartoœci miar
	- wyjaœniê jedn¹ z nich, pozosta³e przebiegaj¹ analogicznie
	COUNT(CASE status WHEN "zainteresowany" THEN 1 ELSE null END)
	"W przypadku, gdy status przyjmuje wartoœæ "zainteresowany" zaliczamy go 1 raz w przeciwnym pomijamy"
Dostarczone dane nie pozwoli³y zweryfikowaæ poprawnoœci zapytania, wiêc doda³em kilka rekordów do tabeli statuses, aby uzyskaæ bardziej "miarodajne" informacje.

Do pierwszego zadania wykorzysta³em œrodowisko Intellij IDEA, natomiast do zadañ 2 i 3 u¿y³em phpMyAdmin.
Dane z pliku statuses.csv z powodzeniem zaimportowa³em do phpMyAdmin.
Wydaje mi siê, ¿e nazwa atrybutu `data` mo¿e nie byæ bezpieczna, tym razem siê uda³o.